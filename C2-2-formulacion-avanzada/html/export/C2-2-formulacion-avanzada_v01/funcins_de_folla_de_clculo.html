<!doctype html>
<html lang="gl">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>Funcións de folla de cálculo | Formulación avanzada en Calc </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="author" content="Rafael Rodríguez Gayoso (gl) - Ismael Fanlo y Salvador Doménech" />
<link rel="license" type="text/html" href="http://creativecommons.org/licenses/by-sa/4.0/" />
<meta name="generator" content="eXeLearning  - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-51"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Saltar navegación</a></p>
<header id="header" ><div id="headerContent">Formulación avanzada en Calc</div></header>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Formulación avanzada</a></li>
   <li><a href="uso_do_asistente_de_funcins.html" class="no-ch">Uso do Asistente de funcións</a></li>
   <li><a href="uso_de_nomes_en_frmulas_e_funcins.html" class="no-ch">Uso de nomes en fórmulas e funcións</a></li>
   <li><a href="uso_de_expresins_lxicas.html" class="no-ch">Uso de expresións lóxicas</a></li>
   <li><a href="aniado_de_funcins.html" class="no-ch">Aniñado de funcións</a></li>
   <li><a href="uso_de_comodns_ou_expresins_regulares.html" class="no-ch">Uso de comodíns ou expresións regulares</a></li>
   <li><a href="funcins_de_contar_e_sumar.html" class="no-ch">Funcións de contar e sumar</a></li>
   <li><a href="funcins_de_texto.html" class="no-ch">Funcións de texto</a></li>
   <li><a href="funcins_de_data_e_hora.html" class="no-ch">Funcións de data e hora</a></li>
   <li><a href="funcins_lxicas.html" class="no-ch">Funcións lóxicas</a></li>
   <li id="active"><a href="funcins_de_folla_de_clculo.html" class="active no-ch">Funcións de folla de cálculo</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="funcins_lxicas.html" class="prev"><span><span>&laquo; </span>Anterior</span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">Funcións de folla de cálculo</h1></header>
<article class="iDevice_wrapper FreeTextIdevice" id="id120">
<div class="iDevice emphasis0">
<div id="ta120_1" class="block iDevice_content">
<p>En <strong>Calc</strong> existe unha categoría de funcións denominada <strong>Folla de cálculo</strong>, que ofrecen un importante conxunto de funcións para obter referencias e información sobre a localización e contido de celas, intervalos, filas ou columnas dentro da folla de cálculo.</p>
<p>Noutros programas de folla de cálculo, esta categoría de funcións denomínase como <strong>funcións de busca e referencia</strong>.</p>
<h2>Función PROCV() e PROCH()</h2>
<p>A función <strong>PROCV</strong> (V por Vertical) permítenos buscar un valor na primeira columna dunha táboa de datos e obtener o contido doutra columna da táboa na mesma fila do valor buscado.</p>
<p>A función <strong>PROCH</strong> (H por horizontal) funciona de forma análoga pero en tablas orientadas en filas en vez de en columnas. É dicir, a busca faise na primeira fila e obtense o valor doutra fila na mesma columna.</p>
<p>Nos dousa casos, podemos elixir entre que a busca sexa exacta ou aproximada, nese caso é necesario que estea ordenada a primeira columna ou fila, segundo se trate de <strong>PROCV</strong> ou <strong>PROCH</strong>.</p>
<p>Vamos a detallar o funcionamento de <strong>PROCV</strong>, tendo presente que a información ofrecida é perfectamente aplicable a <strong>PROCH</strong> sempre que teñamos os datos en filas.</p>
<p><strong>PROCV</strong> busca un valor específico na primeira columna e devolve o valor correspondente á mesma fila desde outra columna.  </p>
<p>Sintaxe básica:</p>
<p style="text-align: center;"><strong><span style="font-family: 'courier new', courier;">=PROCV(Dato_buscado;Intervalo_onde_buscar;Número_columna;Busca_aproximada)</span></strong></p>
<p>onde:</p>
<ul>
<li><strong>Dato_buscado</strong> é o valor que se desexa localizar na primeira columna do <strong>Intervalo_onde_buscar</strong>.</li>
<li><strong>Intervalo_onde_buscar</strong> é a táboa de datos na que se fará a busca na primeira columna.</li>
<li><strong>Número_columna</strong> é o número de columna do intervalo que contén o valor que se desexa obter (é o número de columna dentro do intervalo, sen importar que se trate da columna <strong>A</strong>, a<strong> Z</strong> ou calquera outra)</li>
<li><strong>Busca_aproximada</strong> é un argumento opcional; se se omite, ou é <strong>1,</strong> ou <strong>VERDADERO</strong>, entón a busca será aproximada e situarase na fila que conteña o maior valor menor ao buscado, o cal esixe que a táboa estea ordenada pola súa primeira columan, se se especifica <strong>0</strong> ou <strong>FALSO</strong> a busca será exacta e se non ten éxito devolverá o valor de erro <strong>#N/D</strong> (Non dispoñible), </li>
</ul>
<p>Tal e como se comentou cando se definiu a función <strong>SE</strong>, un exceso de funcións <strong>SE</strong> aniñadas podía substituirse por unha función <strong>PROCV</strong>.  Vexamos un exemplo do caso.</p>
<p>Temos que obter as cualificacións duns alumnos en función da súa nota final. No intervalo <strong>E7:F10</strong> hai unha táboa cos diferentes tramos de cualificación (engadironse títulos para facilitar a súa comprensión pero non son relevantes a efectos da fórmula). A continuación, a solución:</p>
<p><img src="C2-2-formulacion-avanzada-106.png" alt="Resolver calificaciones con SI anidados" title="Resolver calificaciones con SI anidados" style="display: block; margin-left: auto; margin-right: auto;" width="888" height="300" /></p>
<p>Dada a complexidade da fórmula imos detallar o seu comportamento. Co primeiro <strong>SE</strong> comprobamos se a nota é inferior a <strong>5</strong>, en caso afirmativo o resultado é un <strong>Suspenso</strong>; en caso contrario, no segundo <strong>SE</strong> comprobamos se a nota é inferior a <strong>7</strong>, en caso afirmativo o resultado é un <strong>Aprobado</strong>; se non se cumpre ningunha das anteriores, aínda hai dúas posibilidades máis; que sexa <strong>Notable</strong> ou <strong>Excelente</strong>, polo que volvemos a utilizar un terceiro <strong>SE</strong> que comproba se a nota é menor a <strong>9</strong>, que en caso afirmativo, trátase dun <strong>Notable</strong>; e como xa non quedan máis posibilidades, non fai falta engadir ninguna comprobación máis, poi se non é <strong>Suspenso</strong>, nen <strong>Aprobado</strong>, nen <strong>Notable</strong>, tan só pode ser <strong>Excelente</strong>.</p>
<p>A fórmula resultaría máis lexible se se escribiran directamente as notas de corte e as cualificacións dentro da mesma, pero se nun momento determinado se decide que en vez de cualificar como Suspenso se califique como Insuficiente, ou que a nota de corte do aprobado sexa o 6 en lugar do 5, non teríamos máis remedio que volver a escribr a fórmula. Tal e como fixemos, cambiando os valores na táboa de tramos de cualificación, a fórmula seguirá funcionando á perfección.</p>
<p>É comprensible pensar que é moi doado cometer erros ao escribir unha fórmula como esta, e que ademáis resultará difícil localizarlos.</p>
<p>Vexamos como resolver o mesmo problema coa función <strong>PROCV</strong>.</p>
<p><img src="C2-2-formulacion-avanzada-107.png" alt="Resolver calificaciones con BUSCARV" title="Resolver calificaciones con BUSCARV" style="display: block; margin-left: auto; margin-right: auto;" width="882" height="299" /></p>
<p>Podemos comprobar a simplicidade e elegancia desta outra solución. <strong>PROCV</strong> busca a nota dentro da primeira columna do intervalo cos tramos de cualificación e devolve o contido da columna 2 do intervalo. Ao tratarse dunha busca aproximada (omitimos o cuarto argumento), se non atopa a nota, quédase no tramo anterior; por exemplo buscando a nota 3, como non a atopa, queda no tramo do 0, se busca un 8 queda no tramo do 7, etc.</p>
<p>Para este caso foino moi útil o uso da busca aproximada. Tamén sería o caso de crear un modelo de folla de cálculo para, por exemplo, a declaración da renta, cunha base liquidable organizada por tramos.</p>
<p>Pero non seempre será o máis axeitado. Imaxinemos un sistema de facturación donde temos que emitir unha factura ao cliente 300 e ao non atopalo, <strong>Calc</strong> emitise a factura ao cliente 290. Para casos así, necesitaremos o uso do cuarto argumento para que o comportamento de <strong>PROCV</strong> sexa o correspondente ao dunha busca exacta.</p>
<p>Vexamos o seguinte exemplo. Trátase dunha pequena lista de datos e un formulario. No formulario, ao introducir un <strong>Id</strong> de contacto na cela sombreada en amarelo, debe amosarse correctamente o <strong>Nome</strong>, <strong>Cidade</strong> e <strong>Importe</strong> correspondente a ese <strong>Id</strong>.</p>
<p>En principio, usando o <strong>PROCV</strong> como fixemos ata agora, parece funcionar ben.</p>
<p><img src="C2-2-formulacion-avanzada-108.png" alt="Búsqueda aproximada con BUSCARV " title="Búsqueda aproximada con BUSCARV " style="display: block; margin-left: auto; margin-right: auto;" width="943" height="216" /></p>
<p>Pero se introducimos un <strong>Id</strong> inexistente, amosaranos un dato incorrecto; neste caso ao non atopar o <strong>Id</strong> 8, amósanos os datos correspondentes ao <strong>Id</strong> 7.</p>
<p><img src="C2-2-formulacion-avanzada-109.png" alt="Búsqueda aproximada con BUSCARV no sirve en ocasiones" title="Búsqueda aproximada con BUSCARV no sirve en ocasiones" style="display: block; margin-left: auto; margin-right: auto;" width="927" height="214" /></p>
<p>Modifiquemos a fórmula engadindo un cuarto argumento <strong>0</strong> á función <strong>PROCV</strong> e amosaranos o erro <strong>#N/A</strong> advertindo da inexistencia do <strong>Id </strong>8.</p>
<p><img src="C2-2-formulacion-avanzada-110.png" alt="Búsqueda exacta con BUSCARV mostrará el error" title="Búsqueda exacta con BUSCARV mostrará el error" style="display: block; margin-left: auto; margin-right: auto;" width="940" height="212" />Naturalmente, se o <strong>Id</strong> introducido é correcto, a fórmula amosará os datos correctos.</p>
<p><img src="C2-2-formulacion-avanzada-111.png" alt="Búsqueda exacta con BUSCARV dará el resultado correcto" title="Búsqueda exacta con BUSCARV dará el resultado correcto" style="display: block; margin-left: auto; margin-right: auto;" width="945" height="214" /></p>
<div class="destacado">
<p><img src="icon_idea.gif" alt="Idea" title="Idea" width="37" height="30" /><strong>Idea</strong></p>
<p>O caso do exemplo funcionará correctamente aínda que os datos estean nun documento diferente, ¡incluso pechado!.</p>
<p>Podemos comprobalo executando os seguintes pasos:</p>
<ol>
<li>Reproducimos nun novo documento o exemplo amosado nunha folla denominada DATOS.</li>
<li>Moveremos os datos do formulario a unha folla diferente dentro do mesmo documento denominada FORMULARIO.</li>
<li>Moveremos a folla FORMULARIO a un libro novo.</li>
<li>Gardaremos o documento coa folla DATOS e pechámolo.</li>
<li>No libro coa folla FORMULARIO, probaremos diferentes valores para a cela co Id.</li>
</ol>
<p>Observaremos que a fórmula segue funcionando á perfección.</p>
</div>
<p>Vimos que <strong>PROCV</strong> busca na primeira columna (ou na primeira fila se se trata de <strong>PROCH</strong>), pero que ocorre se o dato que necesitamos buscar está noutra columna?</p>
<p>Por exemplo, se no exemplo anterior, temos que buscar un <strong>Nome</strong> para atopar o seu <strong>Id</strong>.</p>
<p>Co que coñecemos ata o momento no teríamos máis remedio que modificar a táboa cambiando a orde das columnas.</p>
<p>Pero iso non será preciso grazas a outras <strong>funcións de folla de cálculo</strong> como<strong> ÍNDICE </strong>e<strong> COINCIDIR</strong>. Imos a estudar o seu funcionamento.</p>
<h2>Función ÍNDICE()</h2>
<p><strong>ÍNDICE</strong> devolve unha referencia a unha cela ou un intervalo dentro dun intervalo en base á súa posición de fila ou columna.</p>
<p>Sintaxe básica:</p>
<p style="text-align: center;"><strong><span style="font-family: 'courier new', courier;">=ÍNDICE(Intervalo;Número_fila;Número_columna;Número_área)</span></strong></p>
<p>onde</p>
<ul>
<li><strong>Intervalo</strong> é o intervalo de referencia, que pode ser múltiple, é dicir, composto por varias áreas, que entón deberá ir entre parénteses.</li>
<li><strong>Número_fila</strong> é un argumento opcional que indica o número de fila dentro do intervalo. Se é cero, devolve todas as filas.</li>
<li><strong>Número_columna</strong> é un argumento opcional que indica o número de columna dentro do intervalo. Se é cero, devolve todas as columnas.</li>
<li><strong>Número_área</strong> é un argumento opcional que indica o número de área se o <strong>Intervalo</strong> é múltiple.</li>
</ul>
<p>No seguinte exemplo, amósase o contido da segunda fila e terceira columna do intervalo de datos.</p>
<p><img src="C2-2-formulacion-avanzada-112.png" alt="Función ÍNDICE" title="Función ÍNDICE" style="display: block; margin-left: auto; margin-right: auto;" width="1094" height="215" /></p>
<p>Se o intervalo é unha soa fila ou columna, o uso é trivial. No exemplo seguinte, amósase o cuarto elemento da lista de nomes.</p>
<p><img src="C2-2-formulacion-avanzada-113.png" alt="Función ÍNDICE aplicada a una sola columna" title="Función ÍNDICE aplicada a una sola columna" style="display: block; margin-left: auto; margin-right: auto;" width="582" height="296" /></p>
<p>Un uso máis sofisticado, dado que a función <strong>ÍNDICE</strong> realmente devolve unha referencia, sería calcular o promedio da cuarta columna do intervalo.</p>
<p><img src="C2-2-formulacion-avanzada-114.png" alt="Función ÍNDICE devolviendo referencia a un rango" title="Función ÍNDICE devolviendo referencia a un rango" style="display: block; margin-left: auto; margin-right: auto;" width="584" height="298" /></p>
<h2>Función CORRESP()</h2>
<p>A diferencia da anterior, <strong>CORRESP</strong> devolve a posición dun dato dentro dun intervalo (fila ou columna).</p>
<p><strong>CORRESP</strong> devolve a posición relativa dentro dun intervalo formado por unha soa fila ou columna.</p>
<p>Sintaxe básica:</p>
<p style="text-align: center;"><span style="font-family: 'courier new', courier;"><strong>=CORRESP(Dato_buscado;Intervalo;Tipo)</strong></span></p>
<p>onde </p>
<ul>
<li><strong>Dato_buscado</strong> é el dato que se busca. Admite expresións regulares se o <strong>Tipo</strong> é cero.</li>
<li><strong>Intervalo</strong> é a fila ou columna onde se desexa atopar o <strong>Dato_buscado</strong>.</li>
<li><strong>Tipo</strong> é un argumento opcional que especifica o tipo de busca:
<ul>
<li>Omitido ou 1: considerase que <strong>Intervalo </strong>está ordenado ascendentemente e a busca será aproximada, devolvendo a posición do maior elemento menor ou igual ao buscado.</li>
<li>0: efectuará unha busca exacta, admitindo expresións regulares no <strong>Dato_buscado</strong>.</li>
<li>-1: asume que <strong>Intervalo</strong> está ordenado descendentemente e a busca será aproximada, devolvendo a posición do último elemento maior ou igual ao buscado.</li>
</ul>
</li>
</ul>
<p>No seguinte exemplo búscase a posición de <strong>Carmen</strong> dentro da lista de nomes. Obsérvese o uso de expresións regulares no dato buscado.</p>
<p><img src="C2-2-formulacion-avanzada-115.png" alt="Función COINCIDIR" title="Función COINCIDIR" style="display: block; margin-left: auto; margin-right: auto;" width="629" height="329" /></p>
<p>Agora, combinando o uso de <strong>CORRESP</strong> e <strong>ÍNDICE</strong> podemos superar a limitación de <strong>PROCV</strong> que restrinxe a busca á primeira columna.</p>
<p>No exemplo, buscamos o nome <strong>Pep.*</strong> e obtemos o <strong>Id</strong> correspondente.</p>
<p><img src="C2-2-formulacion-avanzada-116.png" alt="Uso combinado de ÍNDICE y COINCIDIR" title="Uso combinado de ÍNDICE y COINCIDIR" style="display: block; margin-left: auto; margin-right: auto;" width="732" height="323" /></p>
<p>Mediante <strong>CORRESP</strong> atópase a posición relativa do nome buscado dentro da lista de nomes, e o resultado é o argumento que se pasa a <strong>ÍNDICE</strong> para que devolva o <strong>Id</strong> correspondente.</p>
<p>Acabamos de ver a "maxia" que podemos facer combinando as diferentes funcións que <strong>Calc</strong> pon ao noso dispor.</p>
<p>Unha vez máis recomendamos unha exploración en profundidade doutras funcións que non se trataron nestes apartados.</p>
<p>Todo o tempo que se invirta nesta tarefa, será recompensado con creces cando o poidamos aplicar ao noso traballo diario.</p>
</div>
</div>
</article>
<div id="packageLicense" class="cc cc-by-sa">
<p><span>Licenciado baixo a</span> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Licenza Creative Commons Recoñecemento Compartir igual 4.0</a></p>
</div>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="funcins_lxicas.html" class="prev"><span><span>&laquo; </span>Anterior</span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>